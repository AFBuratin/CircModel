\documentclass{article}
\usepackage[margin=2cm]{geometry}
\title{Sensitivity and precision using the DM1 dataset}
\author{Alessia Buratin}
\begin{document}
%\SweaveOpts{concordance=TRUE}
\maketitle

\section{Load the benchmarking results}

We load the benchmarking results, which were produced by the script 
\texttt{glm\_glmm\_paired.R}.

<<loadData>>=
basedir = "/blackhole/alessia/CircModel/"
load(file = "/blackhole/alessia/CircModel/power/IPF_sensitivityPrecision_CCP2_glmglmm_30rep.RData")
load(file = "/blackhole/alessia/CircModel/power/ALZ_sensitivityPrecision_CCP2_glmglmm_30rep.RData")

@ 

The evaluation set results are contained in the \texttt{resTes} object 
and the verification set results are contained in the \texttt{resHeldout} object,
each a list, one element for each random replicate, of data frames which contain
a column for each algorithm giving the adjusted $p$-values for each circRNA. 
For $p$-value adjustment, the \textit{p.adjust} function was used with 
\texttt{method="BH"} (Benjamini-Hochberg correction), 
over only those genes with non-zero row sum.

<<functions>>=
library("ggplot2")
library("reshape")
library("data.table")
library("dplyr")
alpha=.1
getCalls <- function(m, alpha=NULL) {
  t(sapply(1:nreps, function(i) sapply(namesAlgos, function(algo) {
    sum(m[[i]][[algo]][!is.na(m[[i]][[algo]])]<0.1)
    # sum((m[[i]][[algo]] < alpha))
  })))
}

getSensitivityAlgo <- function(m, alpha, alphaOut) {
  t(sapply(1:nreps, function(i) sapply(namesAlgosALL, function(algo) {
    sigHeldout <- resHeldout[[m]][[i]][[algo]] <= alpha
    mean((resTes[[m]][[i]][[algo]] <= alpha)[sigHeldout])
  })))
}

getPrecisionAlgo <- function(m, alpha, alphaOut) {
  t(sapply(1:nreps, function(i) sapply(namesAlgosALL, function(algo) {
    sigTest <- resTes[[m]][[i]][[algo]] <= alpha #Evaluation set
    if (sum(sigTest) == 0) return(0)
    mean((resHeldout[[m]][[i]][[algo]] <= alpha)[sigTest]) #TP rate
  })))
}

getSensitivityAlgoGold <- function(m, alpha, alphaOut, gold) {
  t(sapply(1:nreps, function(i) sapply(namesAlgosALL, function(algo) {
    sigHeldout <- resHeldoutALL[[m]][[i]][[gold]] < alphaOut
    mean((resTestALL[[m]][[i]][[algo]] < alpha)[!is.na(sigHeldout)])
  })))
}

getPrecisionAlgoGold <- function(m, alpha, alphaOut, gold) {
  t(sapply(1:nreps, function(i) sapply(namesAlgosALL, function(algo) {
    sigTest <- resTestALL[[m]][[i]][[algo]] < alpha
    if (sum(sigTest) == 0) return(0)
    mean((resHeldoutALL[[m]][[i]][[gold]] < alphaOut)[!is.na(sigTest)])
  })))
}
@ 

The following function helps to rename algorithms. 

<<renameAtoB>>=
renameAtoB <- function(f,a,b) {
  levels(f)[levels(f) == a] <- b
  f
}
@ 

<<namesAlgos>>=
namesAlgos <- make.names(names(resTes[[1]]))
names(namesAlgos) <- namesAlgos
@ 

<<colorAlgorithm>>=
library(RColorBrewer)
# display.brewer.all()

cols <- c(
  # DEseq
  brewer.pal(n = 9, "YlOrRd")[c(3,4,5,6)],
  # Edger
  brewer.pal(n = 9, name = "GnBu")[c(5,6,7)],
  # limma
  brewer.pal(n = 9, "RdPu")[c(5)],
  # circMeta
  brewer.pal(n = 9, "OrRd")[c(8)],
  # GLMM
  brewer.pal(n = 9, "BuPu")[c(5)]

)

methods2 <- c("DESeq2",
             "DESeq2-ZeroInflated",
             "DESeq2-GamPoi",
             "DESeq2-ZINB Wave",
             "edgeR",
             "edgeR-robust",
             "edgeR-ZINB Wave",
             "voom",
             "circMeta",
             "GLMM")

names(cols) <- methods2

@

\clearpage

\section{Counting number of calls}

Here we produce boxplots of the number of calls based on adjusted $p$-value
for each algorithm in the evaluation set and verification set for each random replicate.

<<countCalls>>=
nreps <- length(resHeldout)
nalgo <- length(namesAlgos)
# nmethods <- length(names(resHeldout))

heldMat <- getCalls(m = resHeldout, alpha = .1)
testMat <- getCalls(m = resTes, alpha = .1)

d <- data.frame(heldoutCalls=reshape2::melt(heldMat)$value,
                testCalls=reshape2::melt(testMat)$value,
                algorithm=factor(rep(namesAlgos,each=nrow(heldMat)),
                levels=namesAlgos))
                #detection.method=rep(factor(rep(names(resHeldout), each=nrow(heldMat))), nalgo))
d$algorithm <- renameAtoB(d$algorithm, "edgeR.robust", "edgeR-robust")
d$algorithm <- renameAtoB(d$algorithm, "edgeR.ZINBWave", "edgeR-ZINB Wave")
d$algorithm <- renameAtoB(d$algorithm, "DESeq2.ZINBWave", "DESeq2-ZINB Wave")
d$algorithm <- renameAtoB(d$algorithm, "DESeq2.ZI", "DESeq2-ZeroInflated")
d$algorithm <- renameAtoB(d$algorithm, "DESeq2.glmGamPoi", "DESeq2-GamPoi")
d$algorithm <- renameAtoB(d$algorithm, "GLMM_NB", "GLMM")

d$algorithm <- as.character(d$algorithm)

d <- d %>%
  mutate_if(sapply(d, is.character), as.factor)
d$heldoutCalls <- as.numeric(d$heldoutCalls)
d$testCalls <- as.numeric(d$testCalls)
@

<<testCalls, dev="pdf", fig.align="center", fig.width=8, fig.height=6, fig.cap="Evaluation set calls (adjusted $p$-value $< .1$)">>=
p <- ggplot(d, aes(x=reorder(algorithm,testCalls,median),y=testCalls,color=algorithm))
png("/blackhole/alessia/CircModel/power/Figure/DEcalls_evaluation_ALZ.png", res = 200, units = "cm", width = 25, height = 15)
p + geom_boxplot(outlier.colour=rgb(0,0,0,0)) + theme_bw() +
    geom_point(position = position_jitter(w = 0.1, h = 0), color="grey50", size=1) +
    # facet_grid(.~detection.method) +
    scale_color_manual(values = cols, guide="none") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12),
          axis.text.y = element_text(size = 9),
          axis.text.y.left = element_text(size = 12),
          strip.text.x = element_text(size = 9)) + xlab("") + 
    ylab("number of DE calls in Evaluation set")
dev.off()
@ 

<<heldoutCalls, dev="pdf", fig.align="center", fig.width=8, fig.height=6, fig.cap="Verification set calls (adjusted $p$-value $< .1$)">>=
p <- ggplot(d, aes(x=reorder(algorithm,heldoutCalls,median),y=heldoutCalls,color=algorithm))
png("/blackhole/alessia/CircModel/power/Figure/DEcalls_verification_ALZ.png", res = 200, units = "cm", width = 25, height = 15)
p + geom_boxplot(outlier.colour=rgb(0,0,0,0)) + theme_bw() +
    geom_point(position = position_jitter(w = 0.1, h = 0), color="grey50", size=1) +
    # facet_grid(.~detection.method) +
    scale_color_manual(values = cols, guide="none") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12),
          axis.text.y = element_text(size = 9),
          axis.text.y.left = element_text(size = 12),
          strip.text.x = element_text(size = 9)) + xlab("") + 
    ylab("number of DE calls in Verification set")
dev.off()
@ 

\clearpage

\section{Sensitivity and precision plots}

We construct a data frame containing the sensitivity and
precision estimates for every algorithm in the 
evaluation set and the verification set.

<<constructGrid>>=
nreps = 30
gold = "GLMM_NB"
alpha = .1 
alphaOut = .1
resHeldout = lapply(resHeldout, function(x){z=x[complete.cases(x),]
return(z)})
resTes = lapply(resTes, function(x){z=x[complete.cases(x),]
return(z)})

res = t(sapply(1:nreps, function(i) sapply(namesAlgos, function(algo) {
    sigHeldout <- resHeldout[[i]][[gold]] < alphaOut
    mean((resTes[[i]][[algo]] < alpha)[sigHeldout])
  })))

sensMat  = data.frame(res, heldout=rep("GLMM",nrow(res)))

sensMelt <- suppressWarnings(melt(sensMat, id=c("heldout")))
names(sensMelt) <- c("verification", "evaluation","sensitivity")

res = t(sapply(1:nreps, function(i) sapply(namesAlgos, function(algo) {
    sigTest <- resTes[[i]][[algo]] < alpha
    if (sum(sigTest) == 0) return(0)
    mean((resHeldout[[i]][[gold]] < alphaOut)[sigTest])
  })))
precMat = data.frame(res, heldout=rep("GLMM", nrow(res)))

precMelt <- suppressWarnings(melt(precMat, id=c("heldout")))
names(precMelt) <- c("verification", "evaluation","precision")

d <- data.frame(sensMelt, precision=precMelt$precision)
d$evaluation <- factor(d$evaluation)
d$verification <- factor(d$verification)
@ 

<<renameSensResults>>=
d$evaluation <- renameAtoB(d$evaluation, "edgeR.robust", "edgeR-robust")
d$verification <- renameAtoB(d$verification, "edgeR.robust", "edgeR-robust")
d$verification <- renameAtoB(d$verification, "edgeR.ZINBWave", "edgeR-ZINB Wave")
d$evaluation <- renameAtoB(d$evaluation, "edgeR.ZINBWave", "edgeR-ZINB Wave")
d$evaluation <- renameAtoB(d$evaluation, "DESeq2.ZINBWave", "DESeq2-ZINB Wave")
d$verification <- renameAtoB(d$verification, "DESeq2.ZINBWave", "DESeq2-ZINB Wave")
d$evaluation <- renameAtoB(d$evaluation, "DESeq2.glmGamPoi", "DESeq2-GamPoi")
d$verification <- renameAtoB(d$verification, "DESeq2.glmGamPoi", "DESeq2-GamPoi")
d$evaluation <- renameAtoB(d$evaluation, "DESeq2.ZI", "DESeq2-ZeroInflated")
d$verification <- renameAtoB(d$verification, "DESeq2.ZI", "DESeq2-ZeroInflated")
d$evaluation <- renameAtoB(d$evaluation, "GLMM_NB", "GLMM")
d$verification <- renameAtoB(d$verification, "GLMM_NB", "GLMM")
d <- d %>%
  mutate_if(sapply(d, is.character), as.factor)
# d$verification <- renameAtoB(d$verification, "GLMM", "GLMM-ZINB")
# d$evaluation <- renameAtoB(d$evaluation, "GLMM", "GLMM-ZINB")

@ 

<<sensitivityGrid, dev="pdf", fig.width=8, fig.height=6, fig.cap="Sensitivity, where each algorithm's calls (adjusted $p$-value $< .1$) in the evaluation set (color boxes) is compared against itselfs (adjusted $p$-value $< .1$) in the verification set (grey labels).">>=
# d.glmm <- d.glmm[complete.cases(d.glmm),]
png("/blackhole/alessia/CircModel/power/Figure/Power_sensitivity_ALZ.png", res = 200, units = "cm", width = 25, height = 15)
p <- ggplot(d, aes(x=evaluation,y=sensitivity,color=evaluation))
p + geom_boxplot(outlier.colour=rgb(0,0,0,0)) + theme_bw() + 
  # facet_wrap(~ detection.method) + 
  geom_point(position = position_jitter(w = 0.1, h = 0), color="grey50", size=1) +
  scale_color_manual(values=cols) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 15),
        axis.text.y = element_text(size = 15),
        axis.title=element_text(size=15,face="bold"),
          # axis.text.y.left = element_text(size = 11),
          strip.text.x = element_text(size = 13)) + 
  ggtitle("IPF - Dataset") +
  xlab("")
dev.off()
@

<<precisionGrid, dev="pdf", fig.width=8, fig.height=6, fig.cap="Precision, where each algorithm's calls (adjusted $p$-value $< .1$) in the evaluation set (color boxes) is compared against itselfs (adjusted $p$-value $< .1$) in the verification set (grey labels).">>=
png("/blackhole/alessia/CircModel/power/Figure/Power_precision_ALZ.png", res = 200, units = "cm", width = 25, height = 15)
p <- ggplot(d, aes(x=evaluation,y=precision,color=evaluation))
p + geom_boxplot(outlier.colour=rgb(0,0,0,0)) + theme_bw() + 
  # facet_wrap(~ detection.method) + 
  scale_color_manual(values = cols) + 
  geom_point(position = position_jitter(w = 0.1, h = 0), color="grey50", size=1) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 15),
        axis.text.y = element_text(size = 15),
        axis.title=element_text(size=14,face="bold"),
          # axis.text.y.left = element_text(size = 11),
          strip.text.x = element_text(size = 13)) + 
  ggtitle("IPF - Dataset") +
  xlab("")
dev.off()
@

\clearpage

\section{Area Under Precision Recall Curve (AUPRC)}

<<Recallcurve>>=

precall = function(algo, rep, gold = "GLMM_NB") {
  # rep = 1
  # recall = pr.curve(resTes[[rep]][[algo]][resHeldout[[rep]][[gold]] < alphaOut],
  #                   resTes[[rep]][[algo]][!resHeldout[[rep]][[gold]] < alphaOut], curve = TRUE)$curve[, 1]
  # precision = pr.curve(resTes[[rep]][[algo]][resHeldout[[rep]][[gold]] < alphaOut],
  #                      resTes[[rep]][[algo]][!resHeldout[[rep]][[gold]] < alphaOut], curve = TRUE)$curve[, 2]
  auc = pROC::roc(as.numeric(resHeldout[[rep]][[gold]] < alphaOut),
                  as.numeric(resTes[[rep]][[algo]] < alphaOut))
  # auc = AUC::roc(1-resTes[[rep]][[algo]],
  #                as.numeric(resHeldout[[rep]][[gold]] < alphaOut))
  fg <- 1-resTes[[rep]][[algo]][resHeldout[[rep]][[gold]] <= alphaOut]
  bg <- 1-resTes[[rep]][[algo]][resHeldout[[rep]][[gold]] > alphaOut]
  pr <- try(pr.curve(scores.class0 = fg, scores.class1 = bg, curve = T))
  # plot(pr)
  aupr = data_frame(#recall = pr$curve[,1],
                    #precision = pr$curve[,2],
                    AUC = auc$auc,
                    AUPRC = ifelse(class(pr)[1] == "try-error", NA, pr$auc.integral),
                    B = rep,
                    model = algo)
  return(aupr)
  }

res_accuracy = list()
for(algo in names(resTes[[1]])){
  res = rbindlist(lapply(1:nreps, function(x) precall(algo = algo, rep = x, gold = "GLMM_NB")))
  res_accuracy[[algo]] = res
}
AUPRC = rbindlist(res_accuracy, use.names = T)
AUPRC$model = factor(AUPRC$model)
AUPRC$model <- renameAtoB(AUPRC$model, "edgeR.robust", "edgeR-robust")
AUPRC$model <- renameAtoB(AUPRC$model, "edgeR.ZINBWave", "edgeR-ZINB Wave")
AUPRC$model<- renameAtoB(AUPRC$model, "DESeq2.ZINBWave", "DESeq2-ZINB Wave")
AUPRC$model <- renameAtoB(AUPRC$model, "DESeq2.glmGamPoi", "DESeq2-GamPoi")
AUPRC$model<- renameAtoB(AUPRC$model, "DESeq2.ZI", "DESeq2-ZeroInflated")
AUPRC$model = renameAtoB(AUPRC$model, "GLMM_NB", "GLMM")
p <- ggplot(AUPRC, aes(x = reorder(model, AUPRC), y = AUPRC, color = model))
p + geom_boxplot(outlier.colour=rgb(0,0,0,0)) + theme_bw() + 
  # facet_wrap(~ detection.method) + 
  scale_color_manual(values = cols) + 
  geom_point(position = position_jitter(w = 0.1, h = 0), color="grey50", size=1) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 15),
        axis.text.y = element_text(size = 15),
        axis.title=element_text(size=14,face="bold"),
          # axis.text.y.left = element_text(size = 11),
          strip.text.x = element_text(size = 13)) + 
  xlab("")

@

\section{Clustering of calls}

<<clustSetup>>=
alpha <- .1
library("abind")
library("ggplot2")
library("ggdendro")
library("cowplot")
library("gridExtra")
library("grid")
methods <- c("DESeq2",
             "DESeq2.ZI",
             "DESeq2.apeglm",
             "DESeq2.ZINBWave",
             "edgeR",
             "edgeR.robust",
             "edgeR.ZINBWave",
             # "GLMM-NB", 
             "GLMM-ZINB")

names(cols) <- methods
# first with evaluation sets
nreps = 30
j0 <- lapply(names(resTes), function(m) lapply(1:nreps, function(i) {
  print(i)
  print(m)
  dt <- merge(resTes[[m]][[i]], resTestGLMM[[i]], by="row.names")
  # dt = merge(dt, resTestGLMMZI[[i]], by.x = "Row.names", by.y = "row.names")
  dt = dt[,c(2:9)]
  colnames(dt) <- c(colnames(dt)[c(1:7)], #"GLMM-NB", 
                    "GLMM-ZINB")
  m <- as.matrix(dist(t(dt) <= alpha), method="binary")
  return(m)
}))
j <- lapply(j0, function(x) abind(x, along=3))
average.Jaccard <- lapply(j, function(x) apply(x,c(1,2),mean))
average.Jaccard <- lapply(average.Jaccard, function(x) as.dist(x))
hcTest <- lapply(average.Jaccard, function(x) hclust(x))
names(hcTest) <- names(resTes)

# again with verification sets
j0 <- lapply(names(resHeldout), function(m) lapply(1:nreps, function(i) {
  dt = merge(resHeldout[[m]][[i]], resHeldoutGLMM[[i]], by = "row.names")
  dt = merge(dt, resTestGLMM[[i]], by.x = "Row.names", by.y = "row.names")
  dt = dt[c(2:9)]
  colnames(dt) <-  c(colnames(dt)[c(1:7)], #"GLMM-NB", 
                     "GLMM-ZINB")
  m = as.matrix(dist(t(dt) < alpha),method="binary")
  return(m)
}))
j <- lapply(j0, function(x) abind(x,along=3))
average.Jaccard <- lapply(j, function(x) apply(x,c(1,2),mean))
average.Jaccard <- lapply(average.Jaccard, function(x) as.dist(x))
hcHeldout <- lapply(average.Jaccard, function(x) hclust(x))
names(hcHeldout) <- names(resHeldout)

@

<<clustMethods, dev="pdf", fig.align="center", fig.width=10, fig.height=12, fig.cap="Clustering of calls (adjusted $p$-value $< .1$) with distances based on the Jaccard index">>=

g_horizontal_dendrogram_Heldout <- lapply(hcHeldout, function(h)
  p = ggplot() + 
    geom_segment(data=dendro_data(h)$segments, aes(x=x, y=y, xend=xend, yend=yend)) + 
    geom_label(data=dendro_data(h)$labels, aes(x=x, y=y, label=label, hjust=1,color=label), nudge_y = 0) +
    coord_flip() + scale_y_reverse(expand = c(0,0,0,0)) + scale_x_reverse() +
    scale_color_manual(values = cols) +
    theme(axis.line.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.line.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.text.y=element_blank(),
          axis.title.y=element_blank(),
          axis.text.x=element_blank(),
          axis.title.x=element_blank(),
          panel.background=element_rect(fill="white"),
          panel.grid=element_blank(),
          legend.position = "none",
          panel.spacing = unit(0, "lines"),
          plot.margin = unit(c(0.5,0.5,0.5, 0.5), "cm")) + 
  expand_limits(y = -round(max(segment(dendro_data(h))$y) * 0.5, 1))
)

get_legend_dendo <- get_legend(ggplot() + 
    geom_segment(data=dendro_data(hcHeldout[[1]])$segments, aes(x=x, y=y, xend=xend, yend=yend)) + 
    geom_point(data=dendro_data(hcHeldout[[1]])$labels, aes(x=x, y=y,color=factor(label, levels = names(cols), ordered = T)),size = 5) +
    scale_y_continuous() +
    #scale_y_reverse(expand=c(2,1)) + scale_x_reverse(expand=c(2,1)) +
    scale_color_manual(values = cols) +
    theme(axis.line.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.line.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.text.y=element_blank(),
          axis.title.y=element_blank(),
          axis.text.x=element_blank(),
          axis.title.x=element_blank(),
          panel.background=element_rect(fill="white"),
          panel.grid=element_blank(),
          legend.position = "bottom",
          panel.spacing = unit(0, "lines"),
          plot.margin = unit(c(0.5,0.5,0.5, 0.5), "cm")) +
      guides(color = guide_legend(title = "Methods:",title.position = "left",nrow = 2)))
# now add the title
title <- ggdraw() +
  draw_label(
    "Clustering of calls in Verification set",
    fontface = 'bold',
    x = 0,
    hjust = 0, size = 12
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(0, 0, 0, 7)
  )

# plot_grid(title, plot_grid(cowplot::plot_grid(plotlist = g_horizontal_dendrogram_Heldout, 
#                              ncol = 2, #align = 'vh',
#                              hjust = -0.1, 
#                              vjust = -1.4,
#                              labels = names(heldMat)), 
#           plot_grid(get_legend_dendo, ncol = 1), 
#           nrow = 2, rel_heights = c(1,0.1)),
#   ncol = 1,
#   # rel_heights values control vertical title margins
#   rel_heights = c(0.1, 1)
# )

g_horizontal_dendrogram_Test <- lapply(hcTest, function(h)
  p = ggplot() + 
    geom_segment(data=dendro_data(h)$segments, aes(x=x, y=y, xend=xend, yend=yend)) + 
    geom_label(data=dendro_data(h)$labels, aes(x=x, y=y, label=label, hjust=1,color=label), nudge_y = 0) +
    coord_flip() + scale_y_reverse(expand = c(0,0,0,0)) + scale_x_reverse() +
    scale_color_manual(values = cols) +
    theme(axis.line.y=element_blank(),
          axis.ticks.y=element_blank(),
          axis.line.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.text.y=element_blank(),
          axis.title.y=element_blank(),
          axis.text.x=element_blank(),
          axis.title.x=element_blank(),
          panel.background=element_rect(fill="white"),
          panel.grid=element_blank(),
          legend.position = "none",
          panel.spacing = unit(0, "lines"),
          plot.margin = unit(c(0.5,0.5,0.5, 0.5), "cm")) + 
  expand_limits(y = -round(max(segment(dendro_data(h))$y) * 0.5, 1))
)

# now add the title
titleTest <- ggdraw() +
  draw_label(
    "Clustering of calls in Evaluation set",
    fontface = 'bold',
    x = 0,
    hjust = 0, size = 12
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(0, 0, 0, 7)
  )


# plot_grid(plot_grid(title,
#                     plot_grid(plotlist = g_horizontal_dendrogram_Heldout, 
#                              ncol = 2, #align = 'vh',
#                              hjust = -0.1, 
#                              vjust = -1.4,
#                              labels = names(heldMat)), ncol = 1, rel_heights = c(0.1, 1)),
#                     plot_grid(titleTest,
#                     plot_grid(plotlist = g_horizontal_dendrogram_Test, 
#                              ncol = 2, #align = 'vh',
#                              hjust = -0.1, 
#                              vjust = -1.4,
#                              labels = names(heldMat)), ncol = 1, rel_heights = c(0.1, 1)),
#                     plot_grid(get_legend_dendo, ncol = 1), nrow = 2, rel_heights = c(1,0.1))
Heldplot <- plot_grid(title,
                    plot_grid(plotlist = g_horizontal_dendrogram_Heldout, 
                             ncol = 2, #align = 'vh',
                             hjust = c(-0.1, 0.8, -0.1, 0.8, -0.1, 0.8, -0.1), 
                             vjust = -1.35,
                             labels = names(heldMat), 
                             label_size = 9), ncol = 1, rel_heights = c(0.1, 1))
Testplot <- plot_grid(titleTest,
                    plot_grid(plotlist = g_horizontal_dendrogram_Test, 
                             ncol = 2, #align = 'vh',
                             hjust = c(-0.1, 0.8, -0.1, 0.8, -0.1, 0.8, -0.1), 
                             vjust = -1.35,
                             labels = names(testMat),
                             label_size = 9
                             ), ncol = 1, rel_heights = c(0.1, 1))
png("/blackhole/alessia/circzi/checkCircRNAnormalizationdistribution/robustness_glmm/DM1/Clusteringofcalls.png", res = 200, units = "cm", width = 30, height = 45)
grid.arrange(Heldplot, Testplot, get_legend_dendo, ncol=2, nrow=2, widths=c(2.3, 2.3), heights=c(1, 0.1))
dev.off()
@

\clearpage

\section{Heatmap of calls for a single random replicate}

<<oneExampleTest>>=
alpha <- 0.1
library("gplots")
# which replicate had median number of calls
# lapply(resTes, function(x) median(colMeans(sapply(1:50, function(i) colSums(x[[i]] < alpha)))))
# lapply(resTes, function(x) colMeans(sapply(1:50, function(i) colSums(x[[i]] < alpha))))
i <- 2
nMat <- lapply(names(resTes), function(x) resTes[[x]][[i]]<=alpha)
names(nMat) <- names(resTes)
nMat.glmm <- lapply(nMat, function(x){
  # x = nMat$dcc
  # m.glmmNB <- resTestGLMM[[i]][rownames(x),"GLMM"]
  # nMat.glmmNB <- m.glmmNB<=0.1
  # mt <- cbind(x, nMat.glmmNB)
  
  m.glmmZI <- resTestGLMM[[i]][rownames(x),1]
  nMat.glmmZI <- m.glmmZI<=0.1
  # mt <- cbind(mt, nMat.glmmZI)
  mt = cbind(x, nMat.glmmZI)
  
  mt[complete.cases(mt),]
})
# mode(nMat) <- "numeric"
hc <- lapply(nMat.glmm, function(x) hclust(dist(t(x[complete.cases(x),]), method="binary")))
# hc <- hclust(dist(t(nMat), method="binary"))
y <- lapply(names(nMat.glmm), function(x) sweep(nMat.glmm[[x]],2,2^(ncol(nMat.glmm[[x]])-order(hc[[x]]$order)),"*"))
names(y) <- names(nMat.glmm)
z <- lapply(names(nMat.glmm), function(x) nMat.glmm[[x]][order(-rowSums(y[[x]])),])
names(z) <- names(nMat.glmm)
z = lapply(z, function(x){
  mode(x) <- "numeric"
  return(x)
})
@ 

<<heatmapTest, dev="png", fig.align="center", fig.width=10, fig.height=15, out.width="5in", out.height="7.5in", fig.cap="Example of evaluation set calls (adjusted $p$-value $< .1$) for a single replicate of the random sampling">>=
for(m in names(z)){
  heatmap.2(x = z[[m]], main=paste(nrow(nMat.glmm[[m]][rowSums(nMat.glmm[[m]]!=FALSE)>0,]),"out of", 
                                   nrow(resTes[[m]][[i]]),
                                 "circRNAs"), ylab = m, 
            trace="none", key=FALSE,
            Rowv=FALSE,labRow=FALSE,
            Colv=as.dendrogram(hc[[m]]),
            dendrogram="column",
            scale="none",col=c("grey","red"),
            mar=c(15,5),
            lwid=c(2,10),
            cexCol=2.5)
  }
@

<<oneExampleHeldout>>=
nMat <- lapply(names(resHeldout), function(x) resHeldout[[x]][[i]]<=alpha)
names(nMat) <- names(resHeldout)
nMat.glmm <- lapply(nMat, function(x){
  # x = nMat$findcirc
  # m.glmmNB <- resHeldoutGLMM[[i]][rownames(x),"GLMM"]
  # nMat.glmmNB <- m.glmmNB<=0.05
  # mt <- cbind(x, nMat.glmmNB)
  
  m.glmmZI <- resHeldoutGLMMZI[[i]][rownames(x),"GLMM"]
  nMat.glmmZI <- m.glmmZI<=0.1
  mt <- cbind(x, nMat.glmmZI)
  
  mt[complete.cases(mt),]
})
hc <- lapply(nMat.glmm, function(x) hclust(dist(t(x[complete.cases(x),]), method="binary")))
y <- lapply(names(nMat.glmm), function(x) sweep(nMat.glmm[[x]],2,2^(ncol(nMat.glmm[[x]])-order(hc[[x]]$order)),"*"))
names(y) <- names(nMat.glmm)
z <- lapply(names(nMat), function(x) nMat.glmm[[x]][order(-rowSums(y[[x]])),])
names(z) <- names(nMat)
z = lapply(z, function(x){
  mode(x) <- "numeric"
  return(x)
})
@

<<heatmapHeldout, dev="png", fig.align="center", fig.width=10, fig.height=15, out.width="5in", out.height="7.5in", fig.cap="Example of verification set calls (adjusted $p$-value $< .1$) for a single replicate of the random sampling">>=
for(m in names(z)){
  heatmap.2(x = z[[m]], main=paste(nrow(nMat.glmm[[m]][rowSums(nMat.glmm[[m]]!=FALSE)>0,]),"out of", 
                                   nrow(resHeldout[[m]][[i]]),
                                   "circRNAs"), ylab = m, 
            trace="none", key=FALSE,
            Rowv=FALSE,labRow=FALSE,
            Colv=as.dendrogram(hc[[m]]),
            dendrogram="column",
            scale="none",col=c("grey","red"),
            mar=c(15,5),
            lwid=c(2,10),
            cexCol=2.5)
}
@ 

\clearpage

\section{Logarithmic fold changes from a single random replicate}

<<lfcMatrix>>=
i=2
m <- lapply(names(lfcHeldout), function(x) as.matrix(lfcHeldout[[x]][[i]]))
names(m) <- names(lfcHeldout)
# use DESeq2 to remove those genes with all zero counts
m <- lapply(m, function(x) x[!is.na(x[,"DESeq2"]),c(1:7)])
m.glmm <- lapply(m, function(x){
  # m.glmm <- lfcHeldoutGLMM[[i]][rownames(x),]
  m.glmmzi <- lfcHeldoutGLMM[[i]][rownames(x),]
  cbind(x, m.glmmzi)
})
@ 

<<lfcPairs, dev="png", fig.align="center", fig.width=10, fig.height=10, dpi=100, eval=TRUE, fig.cap="Logarithmic (base 2) fold changes for a single replicate of random sampling. Bottom panels show Pearson correlations.">>=
library("LSD")
for(k in names(m.glmm)){
  heatpairs(m.glmm[[k]], xlim=c(-1,1), ylim=c(-1,1), cor.cex=3, main=k)}
@


\clearpage

\section{Session information}

<<sessInfo, echo=FALSE, results="asis">>=
toLatex(sessionInfo())
@ 


\end{document}
